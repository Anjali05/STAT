<para>
STAT is highly scalable and its default analysis has been shown to run effectively on jobs even over one million MPI tasks. Even so, at extreme scales, there are several options that may make STAT's operation even more scalable. The first is to specify the underlying communication tree topology. By default, the <command>stat-cl</command> command and <command>stat-gui</command> will try to deploy the automatic topology, which defaults to a fanout of 64. STAT will, by default, try to co-locate the communication processes on the application nodes (or associated I/O node on BG systems). To avoid the default co-location option for the <command>stat-cl</command> script (remove the <option>-A</option> option). For the <command>stat-gui</command> GUI, create a preferences file and specify an alternative <option>CP policy</option> option. Refer to the options sections to learn about more topology options.
</para>
<para>
Another consideration at scale is the granularity of debug information. At larger scales, you may prefer to start with coarse-grained analysis. For example, you may not need full task lists for the edge labels, but rather, would like to gather edge labels with just the task count and a representative rank. Within the <command>stat-gui</command> GUI, one can then request the full task list of a given edge via the left-click menu of the desired edge's target node. Note, with the <command>stat-cl</command> command, the full task lists would not be gathered and thus would not be available for post-mortem analysis via the stat-view GUI. The count and representative granularity will result in faster sampling and smaller output-file size.
</para>
<para>
The granularity of the stack traces themselves can also be adjusted to alleviate bottlenecks at scale. In particular, symbol resolution can be expensive, particularly when gathering traces at the function and line level of granularity, but even with the function only granularity. This can cause the many STAT daemons to perform many file operation requests at the same time, straining the target file system. To alleviate this issue, you may gather stack traces with the module and offset granularity. The <command>stat-gui</command> and <command>stat-view</command> GUIs can later translate the module and offset into function and line number via <command>addr2line</command>. This translation feature is available only through a left-click of a module and offset node and will translate the entire prefix tree. Note that the file-system bottleneck can also be mitigated with the <option>--with-fgfs</option> configure option, to enable scalable file operations via the <ulink url="https://github.com/dongahn/FastGlobalFileStatus">FastGlobalFileStatus</ulink> module.
</para>
